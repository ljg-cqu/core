// Package auth implement JWT for authentication with H2256 HMAC.
// For more info: https://datatracker.ietf.org/doc/html/rfc7519
// Note: always use HTTPS with JWT, which itself is not encrypted.

// For HMAC signing method, the key can be any []byte. It is recommended to generate
// a key using crypto/rand or something equivalent. You need the same key for signing
// and validating. More: https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.

package auth

import (
	"github.com/golang-jwt/jwt/v4"
	"net/http"
	"time"
)

const (
	AccessTokenKey  = "Access-Token"
	RefreshTokenKey = "Refresh-Token"
)

var (
	signMethod = jwt.SigningMethodHS256

	// The following secrets are generated by SecureKey function in github.com/ljg-cqu/core/utils/
	accessSecret  = "R53bWOY1wRDsAIRgm9hHneMWr8RIR1RuXgZSm0QMdz8dd9tFzieoUmM0K5YzC7qR"
	refreshSecret = "lZRDjRvWeDupnpg46oAHBmXUJVKdpAzu0NFyTktif9gT1gqiHMFhYgvOh8cVq1p7"

	AccessTimeout  = time.Minute * 30
	RefreshTimeout = time.Hour * 24 * 7
)

type AccessTokenDetail struct {
	UserId   string
	UserName string

	AccessTokenStr string
	//SignedMethod   string
	//AccessTokenUuid string
	AccessExpireAt time.Time
}

type RefreshTokenDetail struct {
	UserId   string
	UserName string

	RefreshTokenStr string
	//SignedMethod     string
	//RefreshTokenUuid string
	RefreshExpireAt time.Time
}

type TokenPair struct {
	UserId   string
	UserName string

	AccessTokenStr string
	//AccessTokenUuid string
	AccessExpireAt int64

	RefreshTokenStr string
	//RefreshTokenUuid string
	RefreshExpireAt int64
}

func CreateTokenPair(userId, userName string) (*TokenPair, error) {
	tokenPair := &TokenPair{
		UserId:   userId,
		UserName: userName,
		//AccessTokenUuid:  uuid.NewString(),
		AccessExpireAt: time.Now().Add(AccessTimeout).Unix(),
		//RefreshTokenUuid: uuid.NewString(),
		RefreshExpireAt: time.Now().Add(RefreshTimeout).Unix(),
	}

	//Creating Access Token
	accessTokenClaims := jwt.MapClaims{
		//"access_uuid": tokenPair.AccessTokenUuid,
		"user_id":   tokenPair.UserId,
		"user_name": tokenPair.UserName,
		"exp":       tokenPair.AccessExpireAt,
		//"alg":         signMethod.Alg(),
	}

	accessToken := jwt.NewWithClaims(signMethod, accessTokenClaims)

	accessTokenStr, err := accessToken.SignedString([]byte(accessSecret))
	if err != nil {
		return nil, err
	}
	//accessTokenStr = base64.StdEncoding.EncodeToString([]byte(accessTokenStr))
	tokenPair.AccessTokenStr = accessTokenStr

	//Creating Refresh Token
	refreshTokenClaims := jwt.MapClaims{
		//"refresh_uuid": tokenPair.RefreshTokenUuid,
		"user_id":   tokenPair.UserId,
		"user_name": tokenPair.UserName,
		"exp":       tokenPair.RefreshExpireAt,
		//"alg":          signMethod.Alg(),
	}

	refreshToken := jwt.NewWithClaims(signMethod, refreshTokenClaims)

	refreshTokenStr, err := refreshToken.SignedString([]byte(refreshSecret))
	if err != nil {
		return nil, err
	}
	//refreshTokenStr = base64.StdEncoding.EncodeToString([]byte(refreshTokenStr))
	tokenPair.RefreshTokenStr = refreshTokenStr

	return tokenPair, nil
}

func VerifyAccessToken(req *http.Request) (*AccessTokenDetail, error) {
	tokenStr := req.Header.Get(AccessTokenKey)
	token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
		return []byte(accessSecret), nil
	}, jwt.WithValidMethods([]string{signMethod.Alg()}))

	if err != nil {
		return nil, err
	}

	// TODO: extra token.Valid verification?

	claims := token.Claims.(jwt.MapClaims)

	return &AccessTokenDetail{
		UserId:   claims["user_id"].(string),
		UserName: claims["user_name"].(string),

		AccessTokenStr: tokenStr,
		//SignedMethod:    claims["alg"].(string),
		//AccessTokenUuid: claims["access_uuid"].(string),
		AccessExpireAt: time.Unix(int64(claims["exp"].(float64)), 0),
	}, nil
}

func VerifyRefreshToken(req *http.Request) (*RefreshTokenDetail, error) {
	tokenStr := req.Header.Get(RefreshTokenKey)
	token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
		return []byte(refreshSecret), nil
	}, jwt.WithValidMethods([]string{signMethod.Alg()}))

	if err != nil {
		return nil, err
	}

	// TODO: extra token.Valid verification?

	claims := token.Claims.(jwt.MapClaims)

	return &RefreshTokenDetail{
		UserId:   claims["user_id"].(string),
		UserName: claims["user_name"].(string),

		RefreshTokenStr: tokenStr,
		//SignedMethod:     claims["alg"].(string),
		//RefreshTokenUuid: claims["refresh_uuid"].(string),
		RefreshExpireAt: time.Unix(int64(claims["exp"].(float64)), 0),
	}, nil
}
