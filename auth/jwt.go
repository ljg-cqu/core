// Package auth implement JWT for authentication with H2256 HMAC.
// For more info: https://datatracker.ietf.org/doc/html/rfc7519
// Note: always use HTTPS with JWT, which itself is not encrypted.

// For HMAC signing method, the key can be any []byte. It is recommended to generate
// a key using crypto/rand or something equivalent. You need the same key for signing
// and validating. More: https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.

package auth

import (
	"github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"net/http"
	"time"
)

const (
	AccessJwtKey  = "access_jwt"
	RefreshJwtKey = "Refresh_jwt"
)

var (
	signMethod = jwt.SigningMethodHS256

	// The following secrets are generated by SecureKey function in github.com/ljg-cqu/core/utils/
	accessSecret  = "R53bWOY1wRDsAIRgm9hHneMWr8RIR1RuXgZSm0QMdz8dd9tFzieoUmM0K5YzC7qR"
	refreshSecret = "lZRDjRvWeDupnpg46oAHBmXUJVKdpAzu0NFyTktif9gT1gqiHMFhYgvOh8cVq1p7"

	AccessTimeout  = time.Minute * 30
	RefreshTimeout = time.Hour * 24 * 7
)

type AccessJwtDetail struct {
	UserId   string
	UserName string

	AccessJwt      string
	SignedMethod   string
	AccessJwtUuid  string
	AccessExpireAt time.Time
}

type RefreshJwtDetail struct {
	UserId   string
	UserName string

	RefreshJwt      string
	SignedMethod    string
	RefreshJwtUuid  string
	RefreshExpireAt time.Time
}

type JwtPair struct {
	UserId   string
	UserName string

	AccessJwt      string
	AccessJwtUuid  string
	AccessExpireAt int64

	RefreshJwt      string
	RefreshJwtUuid  string
	RefreshExpireAt int64
}

func CreateJwtPair(userId, userName string) (*JwtPair, error) {
	tokenPair := &JwtPair{
		UserId:          userId,
		UserName:        userName,
		AccessJwtUuid:   uuid.NewString(),
		AccessExpireAt:  time.Now().Add(AccessTimeout).Unix(),
		RefreshJwtUuid:  uuid.NewString(),
		RefreshExpireAt: time.Now().Add(RefreshTimeout).Unix(),
	}

	//Creating Access CurrentToken
	accessTokenClaims := jwt.MapClaims{
		"access_uuid": tokenPair.AccessJwtUuid,
		"user_id":     tokenPair.UserId,
		"user_name":   tokenPair.UserName,
		"exp":         tokenPair.AccessExpireAt,
		"alg":         signMethod.Alg(),
	}

	accessToken := jwt.NewWithClaims(signMethod, accessTokenClaims)

	accessTokenStr, err := accessToken.SignedString([]byte(accessSecret))
	if err != nil {
		return nil, err
	}
	//accessTokenStr = base64.StdEncoding.EncodeToString([]byte(accessTokenStr))
	tokenPair.AccessJwt = accessTokenStr

	//Creating Refresh CurrentToken
	refreshTokenClaims := jwt.MapClaims{
		"refresh_uuid": tokenPair.RefreshJwtUuid,
		"user_id":      tokenPair.UserId,
		"user_name":    tokenPair.UserName,
		"exp":          tokenPair.RefreshExpireAt,
		"alg":          signMethod.Alg(),
	}

	refreshToken := jwt.NewWithClaims(signMethod, refreshTokenClaims)

	refreshTokenStr, err := refreshToken.SignedString([]byte(refreshSecret))
	if err != nil {
		return nil, err
	}
	//refreshTokenStr = base64.StdEncoding.EncodeToString([]byte(refreshTokenStr))
	tokenPair.RefreshJwt = refreshTokenStr

	return tokenPair, nil
}

func VerifyAccessJwt(req *http.Request) (*AccessJwtDetail, error) {
	tokenStr := req.Header.Get(AccessJwtKey)
	return VerifyAccessJwtByStr(tokenStr)
}

func VerifyAccessJwtByStr(tokenStr string) (*AccessJwtDetail, error) {
	token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
		return []byte(accessSecret), nil
	}, jwt.WithValidMethods([]string{signMethod.Alg()}))

	if err != nil {
		return nil, err
	}

	claims := token.Claims.(jwt.MapClaims)

	return &AccessJwtDetail{
		UserId:   claims["user_id"].(string),
		UserName: claims["user_name"].(string),

		AccessJwt:      tokenStr,
		SignedMethod:   claims["alg"].(string),
		AccessJwtUuid:  claims["access_uuid"].(string),
		AccessExpireAt: time.Unix(int64(claims["exp"].(float64)), 0),
	}, nil
}

func VerifyRefreshJwt(req *http.Request) (*RefreshJwtDetail, error) {
	tokenStr := req.Header.Get(RefreshJwtKey)
	return VerifyRefreshJwtByStr(tokenStr)
}

func VerifyRefreshJwtByStr(tokenStr string) (*RefreshJwtDetail, error) {
	token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
		return []byte(refreshSecret), nil
	}, jwt.WithValidMethods([]string{signMethod.Alg()}))

	if err != nil {
		return nil, err
	}

	claims := token.Claims.(jwt.MapClaims)

	return &RefreshJwtDetail{
		UserId:   claims["user_id"].(string),
		UserName: claims["user_name"].(string),

		RefreshJwt:      tokenStr,
		SignedMethod:    claims["alg"].(string),
		RefreshJwtUuid:  claims["refresh_uuid"].(string),
		RefreshExpireAt: time.Unix(int64(claims["exp"].(float64)), 0),
	}, nil
}
